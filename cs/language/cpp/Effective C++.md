# Effective C++ 笔记

[TOC]

本篇是 *Effective C++ (Scott Meyers)* 的阅读笔记，会遵照原文进行分章。

## 让自己熟悉 **C++**

### 将 **C++** 视为一个语言联邦

首先，**C++** *不是* 带类的 **C**！在语言设计的早期，它确实只有 **C** 的内容以及类相关的新特性。但是在数十年的发展后（截至 2021 年），**C++** 已经焕然一新，支持多种编程范式，这使得其表达力非常强大。但是不可否认，不同风格的 **C++** 可能看起来差异非常大，仿佛两种语言一样。因此这里的提议是将 **C++** 看作一个语言联邦。这并不是说要分裂 **C++**，其语言设计的内核依然是统一的，但是在不同“子语言”中转换时，要做好改变编程策略的准备。我们将 **C++** 主要分为下面四个子语言：

- **C**：毫无疑问 **C++** 的语言核心仍然是 **过程的（Procedural）**，在任何时候你都可以将它写成 **C** 的风格。这并不是说 **C** 是 **C++** 的子集，两者经过多年发展后显然已经分道扬镳；但是如果取出 **C++** 最基础的语言架构，比如 **块（Block）**、**语句（Statement）**、**预处理器（Preprocessor）**、**指针（Pointer）** 等都是沿袭自 **C** 并在 **C++** 中依然大量使用的特性。
- 面向对象的 **C++**：这也是对 **C++** 的刻板印象，“带类的 **C**”为了适用于 **面向对象编程（Object-Oriented Programming, OOP）** 而提供的特性，如 **类（Class）**、**继承（Inheritance）**、**子类型多态（Subtype Polymorphism）** 等。这也是 **C++** 在高速发展年间最被人熟知的部分。如同其它 OOP 语言一样，我们对 **C++** 也应该践行一些通用的 OOP 思想。
- 模版 **C++**：也即 **C++** 对 **范型编程（Generic Programming）** 的支持，其威力极为强大。这部分对于普通程序员来说可能不太熟悉，后文中多数模版相关的条款都是惟模版适用的。
- **STL** **C++**：这里的 **STL** 是指标准模版库，提供了 **容器（Container）**、**迭代器（Iterator）**、**算法（Algorithm）** 等相当有用的工具并需要遵守一定的使用思路。

以函数参数传递方式而言，**C** 风格的 **C++** 多数都是通过值来传递；但面向对象的 **C++** 会毫不犹豫地偏向传入常引用，以避免对象构建与销毁的巨大开销；模版 **C++** 由于不知道传入的类型，多数情况也只能选择常引用；**STL** 中则存在一些同样适合以值传递的类型，比如迭代器。

### 优先使用 `const`、`enum`、`inline` 而非 `#define`

### 尽可能使用 `const`

### 确定对象在使用前已经被初始化

## 构造函数/析构函数/赋值运算符

### 了解 **C++** 默默编写并调用哪些函数

### 如果不想使用编译器自动生成的函数，应该明确禁止它

### 为多态基类声明 `virtual` 析构函数

### 不要让析构函数抛出异常

### 不要在构造和析构函数中使用 `virtual` 函数

### 让 `operator =` 函数返回一个对 `*this` 的引用

### 在 `operator =` 中处理自我赋值

### 复制对象中的每一个成分

## 资源管理

### 以对象管理资源

### 在资源管理类中小心复制行为

### 在资源管理类中提供对原始资源的访问

### 成对使用 `new` 和 `delete` 时使用相同的形式

### 以独立语句将 `new` 得到的对象存入智能指针中

## 设计与声明

### 让接口容易被正确使用

### 将类设计得像一个类型

### 优先以常引用传递而非以值传递

### 不要返回引用类型

### 将成员变量声明为 `private`

### 优先使用非成员函数和非友元函数而非成员函数

### 如果所有参数都需要类型转换，请使用非成员函数

### 考虑写一个不抛出异常的 `swap` 函数

## 实现

### 尽可能延后变量定义出现的地方

### 尽可能减少类型转换

### 避免返回对象内部的“句柄”

### 为异常安全而努力

### 彻底了解内联

### 将文件间的编译依赖关系降到最低

## 继承与面向对象设计

### 确保 `public` 继承体现了 is-a 的关系

### 避免名称覆盖

### 区分对接口和对实现的继承

### 考虑 `virtual` 函数以外的其它选择

### 绝不重新定义继承的非 `virtual` 函数

### 绝不重新定义继承的默认参数值

### 通过组合体现 has-a 关系

### 审慎地使用 `private` 继承

### 审慎地使用多重继承

## 模版和范型编程

### 了解隐式接口和编译器多态

### 了解 `typename` 的双重含义

### 了解如何访问模版化的基类中的名称

### 将与模版参数无关的代码抽出模版

### 通过模版成员函数接受所有兼容类型

### 需要类型转换时在模版中定义非成员函数

### 使用特征类型表现类型信息

### 认识模版元编程

## 自定义 `new` 和 `delete`

### 了解 new-handler 的行为

### 了解替换 `new` 和 `delete` 的合理时机

### 编写 `new` 和 `delete` 时遵守约定

### 如果写了 placement-new，也要写 place-delete

## 杂项

### 注意编译器的警告

### 熟悉包括 **TR1** 在内的标注库

### 熟悉 **Boost**

