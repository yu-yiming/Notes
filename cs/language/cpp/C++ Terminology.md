# C++ 术语

这篇笔记中会收录一些在 **C++** 语言中常见的术语及解释，以拼音顺序排列，用于学习和查阅。其中有一些术语也会出现在其它编程语言当中，我们不作展开说明，只针对其在 **C++** 中的含义进行阐述。

## **C++** 版本

**C++** 历史上拥有 6 个稳定版本（截至 2021 年），即 **C++98**、**C++03**、**C++11**、**C++14**、**C++17**、**C++20**（当前版本）。它们分别对应了五个不同时期的 **C++** 标准。我们会混用 **C++** 标准和 **C++** 版本这两个术语。

### **C++98**

这是 **C++** 的第一个标准，其建立了 **C++** 语言的基础结构。在 **C** 之上，**C++** 引入了 **类（Class）**、**命名空间（Namespace）**、**模版（Template）** 等让其显著区别于前者的概念。

### C++03

这个标准对 **C++98** 中的一些缺陷进行了修复，并没有引入新的语言特性。

### C++11

这是一个非常重要的 **C++** 版本，通常也被称为 **C++1x** 或 **C++0x**（因为按照原计划它会在 2010 年前公布）。此版本中引入了**移动语义**、**常量表达式**、**初始化列表**、**可变参数模版**、**多线程内存模型**、**lambda 表达式** 等语言特性以及 **元组**、**智能指针** 等标准库支持。这些让 **C++** 焕然一新，更加像一门现代语言（在过去它总是被当作“带类的 **C**”）。我们也将所有 **C++11** 及之后的标准的 **C++** 称为 **现代C++**。

### C++14

这个标准对 **C++11** 进行了轻量的更新，增加了如 **函数返回类型推导**、**范型 lambda** 等语言特性和标准库更新，可以说是对 **C++11** 的一个补丁。也被称为 **C++1y**。

### C++17

这个标准对 **C++** 中的一些语法进行了更新和优化。比如 **编译期 if**、**结构化绑定**、`auto` 作为非模版参数类型的声明符等。也被称为 **C++1z**。

### C++20

这是继 **C++11** 后最重要的 **C++** 版本（截止 2021 年），也被称为 **C++2a**。引入了 **概念**、**模块** 等语言特性以及 **范围** 等标准库更新，并对标准库类型的编译期构造提供了部分支持。

## 定义

**定义（Definition）** 是能够提供标识符完整信息的 **声明**。除了以下几种声明外，所有的声明都是定义：

- 没有函数体部分的函数声明，以及这样的函数中的参数声明。
- 拥有 `extern` 存储类型限定符或语言链接限定符（如 `extern "C"`）却没有给出初始化结构的变量声明。
- 在类定义中非静态且非内联的成员声明。
- 没有给出类体的类声明，比如 **前置类声明**，如 `class Foo;`、或在其它标识符声明中使用 **详细类型限定符**，如 `class R foo(struct S s)；`。
- **模糊枚举声明**。
- 模版参数声明，如 `template<typename T>` 中的 `T`。
- `typedef` 声明。
- **别名** 声明。
- `using` 声明。
- 没有引入任何新标识符的声明，如 **静态断言** 声明、属性声明、**类型推导指引**、空声明、`using` 指示（有一个例外是汇编声明，它被归为定义）。
- 使用 `extern template` 的 **显式模版实例化**。
- 没有给出类体的 **显式模版特化**。

详细例子可以参考 **声明** 词条，以及其对应的 **C++** 结构的词条。

### 唯一定义定律（ODR）

**唯一定义定律（One Definition Rule, ODR）** 是指，在一个 **C++** 编译单元中，变量、函数、类、枚举、概念和模版能且仅能被定义一次，虽然其中有些允许多次声明，但是作为定义的声明只能存在一个。我们首先介绍对象的 **ODR 使用**，然后再深入介绍这个定律。

#### ODR 使用

简单理解，当一个对象被读（它是编译期常量时除外）或写、取地址、被作为引用对象时；当一个引用被使用且其引用对象编译期不可知时；当一个函数被调用或取地址时；这个对象，引用，函数就被 **ODR 使用（ODR-use）** 了。此时必须保证它们的定义在程序中存在，否则会出现链接错误。

ODR 使用可以详细地如下阐述：

1. 

## RAII

**RAII（Resource Allocation Is Initialization）**，即资源分配是初始化，是一个 **C++** 的程序设计理念，它将需要主动申请的资源（如 **堆** 内存、**线程**、**套接字**、**文件**、**互斥锁**、**磁盘** 等一切需要管理的有限资源）的生命周期和一个对象的 **生命周期** 绑定起来。**RAII** 保证了下面几点：

- 任何能够访问对象内部的函数都能访问该对象持有的资源。
- 对象 **析构** 时，保证所有其持有的资源都会按照构造时获取的逆序进行释放。
- 构造中资源获取失败时（此时会从构造函数中抛出异常），会将已经获取的资源按照逆序进行释放。

由于这种设计思想和 **C++** 原生的 **作用域** 对标识符的生命周期影响相似，也称其为 **作用域内资源管理（Scope-Bound Resource Management, SBRM）**。其应用方法可以简述为以下几点：

- 将所有资源都封装在类中，并在构造函数中获取资源（并在失败时抛出异常），在析构函数中释放资源且保证不会抛出异常，
- 仅通过自动生命周期的对象或其生命周期受限于“拥有自动生命周期的对象”的对象来获取资源。

**C++11** 引入的 **移动语义** 使得不同对象间、不同作用域间、线程内外安全地转移所有权成为了可能。

## 声明

**声明（Declaration）** 为 **C++** 程序引入新的标识符，这使得编译器能够在后面认出它。**C++** 中所有声明可以分为下面的类型：

- 函数声明：声明了一个 **函数** 并可能给出其定义。
- 模版声明：声明了一个 **类模版**、**函数模版**、**别名模版**、**变量模版**、**概念** 之一并可能给出其定义。
- **显式模版实例化**：声明了一个模版实例化类型，使得此类型会在编译期间被实例化。
- **显式模版特化**：声明一个 **全特化** 的模版。
- 命名空间定义：定义了一个 **命名空间**。
- **链接申明**：嵌入一个特定语言的代码片段，用于链接。
- 属性声明
- 空声明：不包含任何内容的语句，也即空语句。
- 不包含声明限定符序列的函数声明：即没有标明返回值的函数声明。这可能是 **构造函数**、**析构函数**、**类型转换函数** 之一。
- 块内声明：即可以在一个代码 **块** 中出现的声明语句：
  - 汇编声明：嵌入汇编语句的声明。
  - 别名声明：声明一个 **别名** 或别名模版。
  - 命名空间别名定义：定义了一个命名空间的别名。
  - `using` 声明：即 `using` 语句，引入某个命名空间中的标识符。
  - `using` 指示：即 `using namespace ` 语句，引入某个命名空间中所有标识符。
  - `using enum` 声明：即 `using enum` 语句，引入某个枚举中的所有标识符。
  - **静态断言** 声明：即 `static_assert` 语句，进行编译期的断言。
  - **模糊枚举声明**
  - **简单声明（Simple Declaration）**：由可选的属性、一个 **声明限定符序列** 和一个 **初始化声明列表** 组成，其引入了一或多个标识符并可能给出它们的初始值。

上面许多具体内容我们将在其对应的 **C++** 结构的词条中介绍。这里我们用一些例子来简单展示不同类型声明的语法：

```cpp
// 函数声明
int foo() { 
    return 42;
}
// 模版声明
template<typename T, typename U> struct MyTemplate;
// 显式模版实例化
template<typename T>
struct MyTemplate<T, int>;
template<>
struct MyTemplate<std::string, char*> {};
// 命名空间定义
namespace my_namespace {}
// 链接申明
extern "C" void bar() {}
// 属性声明
[[fallthrough]];
// 空声明
;
// 不包含声明限定符序列的函数声明
[[noreturn]] oldcfunction();
int main() {
    int a = 10, b;
    // 汇编声明。这里使用了扩展的汇编语法
    asm("movl %1, %eax;
        "movl %%eax, %0;"
        :"=r"(b)
        :"r"(a)
        :"%eax");
    // 别名声明
    using VectorIterator =  std::vector<int>::iterator;
    // 命名空间别名定义
    using std_experimental = std::experime;
    // using 声明
    using std::vector<int>::const_iterator;
    // using 指示
    using namespace std_experimental;
    enum struct MyEnum { A, B, C };
    // using enum 声明
    using enum MyEnum;
    // 静态断言声明
    static_assert(1 + 1 == 2, "The universe collapsed!");
    // 模糊枚举声明
    enum OpaqueEnum : unsigned;
    // 简单声明
    int i = 10;
    constexpr void baz(int, char);
    class InnerClass {};
}
```

最后需要提及的是，**定义（Definition）** 是声明的一种，其能够完全地定义一个标识符，使得其能够被作为一个实体使用。

## 声明器

**声明器（Declarator）** 是一个描述标识符和其类型特征的结构，是标识符声明的核心部分之一。声明器并不包含任何“实体类型”，而主要由指针符号 `*`、引用符号 `&` 等结构组成。我们可以根据结构将声明器分为下面这些类型：

- `id attr`：一个需要声明的标识符 `id` 和可选的属性 `attr`。比如 `var`。
- `* attr cv declarator`：指针符号、可选的属性 `attr`（修饰指针）、可选的 cv 修饰符 `cv`（修饰指针）及一个声明器。比如 `* const cp`。
- `nested-name-spec* attr cv declarator`：复合的名称限定符（即 `::` 连接的多个标识符）、指针符号、可选的属性 `attr`（修饰指针）、可选的 cv 修饰符 `cv`（修饰指针）及一个声明器。比如 `Foo::* volatile vmp`。
- `& attr declarator`：引用符号、可选的属性 `attr`（修饰引用）及一个声明器。比如 `& ref`。
- `&& attr declarator`：引用符号、可选的属性 `attr`（修饰引用）及一个声明器。比如 `&& rref`。
- `nonptr-declarator [constexpr] attr`：一个最外层没有指针符号和引用符号的声明器 `nonptr-declarator`、一个可选的常量表达式 `constexpr`（外面的方括号不能省略）及一个可选的属性 `attr`。
- `nonptr-declarator (param-list) cv ref except attr -> trailing`：一个最外层没有指针符号和引用符号的声明器 `nonptr-declarator`、一个参数列表 `param-list`、一个可选的 cv 修饰符 `cv`、一个可选的引用符号 `ref`、一个可选的异常限定符 `except`、一个可选的属性 `attr` 及一个可选的尾序返回类型 `trailing`（省略时请也省略前面的 `->` 符号）。比如 `(*foo)(int) const& noexcept -> int`
- `... id attr`：一个参数包符号、一个需要声明的标识符和可选的属性 `attr`。比如 `class... Args`。

### 初始化声明器

**初始化声明器** 是和初始化结构组合的声明器，其有下面两种形式：

- `declarator initializer`：声明器及初始化结构。比如 `*ptr = &i`。
- `declarator req-clause`：声明器及 `requires` 子句。比如 `foo(T) requires std::is_integral_v<T>`。

### 初始化声明列表

初始化声明器用逗号分隔形成的列表被称为 **初始化声明列表**。比如声明 `S D1, D2, D3;` 等价于 `S D1; S D2; S D3;`。

## 限定符

**限定符（Specifier）** 是一个具有特定意义的关键字，其对标识符的声明有很大影响。下面根据其作用不完全地对 **C++** 中的限定符进行罗列：

- 类型限定符（Type Specifier）：`class`、`struct`、`enum`、`union`、`int`、`char`、`double`
- 访问限定符（Access Specifier）：`public`、`protected`、`private`
- 存储类型限定符（Storage Class Specifier）：`auto`、`register`、`static`、`extern`、`thread_local`、`mutable`
- 函数限定符（Function Specifier）：`inline`、`explicit`、`virtual`
- 占位类型限定符（Placeholder Type Specifier）：`auto`、`decltype(auto)`
- 与继承相关：`virtual`、`final`、`override`
- 与初始化有关：`constexpr`、`constinit`

上面省略了一些多个限定符同时使用的情形。可以看到有些限定符会在不同类别中出现，这是因为 **C++** 中部分关键字有“活用”的情形，但通常它们在不同情形中都有类似的含义。下面我们展示一些限定符使用的示例，如果需要每一个标识符具体的介绍请参考其对应词条：

```cpp
// final 限定符紧跟在类型标识符后面，表明这个类型不能被继承
// public 表明这是一个公有继承
class MyClass final : public ExternClass {
// public 标签表明下面的所有成员及成员函数都是 public 访问修饰类型
public:
    // explicit 禁止接受参数时进行隐式类型转换
    explicit MyClass(int i) {
     	s_int = i;   
    }
    // decltype(auto) 告知编译器通过 decltype 类型推导规则判断返回类型
    decltype(auto) get_int() {
        return s_int;
    }
private:
    // static 表明这个变量拥有静态生命周期，其会在编译期分配内存空间
    static int s_int;
}
```

### 声明限定符

**声明限定符（Declaration Specifier）** 是出现在标识符声明语句中的限定符，其可以多个一同出现，被称为 **声明限定符序列**，大体上没有顺序的要求。下面是详细的列表：

- `typedef`：一定出现在最前面，将此声明语句变为 `typedef` 声明语句，其中引入的标识符将是一个类型。
- 函数限定符：比如 `virtual`、`explicit`，只能在函数声明中出现。
- `inline`：可以修饰函数或对象。
- `friend`：可以在函数或类声明中出现
- `constexpr`、`consteval`、`constinit`：在一个声明限定符序列中，这三个限定符只能出现一个。它们规则比较复杂，请参考对应词条。
- 存储类型限定符：比如 `auto`、`register`、`static`。在一个声明限定符序列中，只能出现一个存储类型限定符。一个例外是 `thread_local` 可以和 `extern` 或 `static` 一同出现。
- **类型限定符序列**：包含一到多个类型限定符。这部分比较复杂，我们会在下一个小节中详细介绍。

### 类型限定符序列

一个 **类型限定符序列** 代表一个类型。其中可能包含多个类型限定符，列表如下：

- `class`、`struct`、`union`：表明这是一个类型。
- `enum`：表明这是一个枚举。
- 简单类型限定符：指其本身是一个类型的限定符（其中可能含有修饰符），如：
  - 内置基本类型：比如 `char`、`bool`、`void`、`char8_t` 等。
  - 占位类型限定符：`auto`、`decltype(auto)`。
  - 已经声明的类名、枚举名、`typedef` 名称以及类型别名。
  - 模版名称：比如 `std::vector<int>`、`std::set`。可能带有 **消歧器** `typename` 和 `template`，比如 `typename C<T>::X` 和 `C::template X<T>`。
- 详细类型限定符：以 `class`、`struct`、`union`、`enum` 开始，紧接着一个已经声明的类型或枚举：
  - 类型：此处 `class` 和 `struct` 没有任何区别，可以互换。比如 `struct S`、`class S::X`。
  - 枚举：此处只能使用 `enum`，即使是有作用域的枚举也只需要使用 `enum`。
- `typename`、`class`：声明模版参数类型。
- cv 修饰符：说明指针或类型的特征。

## 修饰符

**修饰符（Qualifier）** 是一个具有特定意义的关键字，通常在 **标识符** 的声明中出现，对变量的性质进行额外说明。在其它语言（以及一些不太规范的 **C++** 文档中）也被称为 **修改符（Modifier）**。修饰符与 **限定符** 的区别在于，其不一定反映标识符所绑定对象的真实性质，而只反映变量的性质。**C++** 中常见的修饰符有 **cv 修饰符**，即  `const` 和 `volatile` 以及 `const volatile` 与 `volatile const`。下面用一些例子来展现它们的特点：

```cpp
void foo(int*, int const*);

int main() {
    int i = 42;
    int const ci = 10;		// int 是一个申明符，而 const 是修饰符，它表明这个不能通过这个变量 i 来修改其绑定的对象
    int const* pci = &i;	// const 是一个申明符，其修饰前面的 int
    						// 表明这个类型是一个指向 int 类型的指针，且不能通过指针的解引用来修改指向对象的内容
    						// 但实际上，其指向的对象 i 并不是一个常变量
    foo(&i, &i);
	return 0;
}

// 第二个参数中出现了修饰符 const，表明其接受的一个指向 int 类型的指针，且其解引用之后不能进行修改
void foo(int* ptr, int const* cptr) {
 	std::cout << *cptr;
    *ptr = 10;
}
```

因此，虽然 cv 修饰符在 **C++** 中作为类型的一部分出现，但其只能反映标识符的性质。在编译过程中，编译器会对拥有修饰符的标识符进行检查和相应的处理（详情可以参考 *cv 修饰符* 词条），除此之外修饰符不反映对象的任何性质。

# 索引

[TOC]

