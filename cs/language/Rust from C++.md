# **Rust** 学习 —— 从 **C++** 角度

**Rust** 语言是一个多范式的通用编程语言。其诞生于 2010 年，可以说相当年轻。它是编译型的静态强类型语言，这一点和 **C/C++** 相似。**Rust** 的设计受 **C++**、**OCaml** 等语言的影响，取各家之长，吸纳了许多现代的语言设计，并凭借其独有的所有权机制大放光彩。自 2016 年以来，它每年都被评选为 **Stack Oerflow** 的最受喜爱编程语言，可见其受欢迎程度。

**Rust** 为高效和安全做出的努力是令人瞩目的，它一方面摒弃 **Java**、**Go** 等语言对 **GC** 的依赖，另一方面对 **C/C++** 的资源管理方式进行了严格的限制，很大程度上保证了内存安全。本篇中我会从 **C++** 的角度分析 **Rust** 语言中的特性并比较优缺点。

在正式开始之前，让我先对 **Rust** 的一些特征进行介绍：

- 语句乃表达式：虽然 **Rust** 的语法风格是 **C** 的风格，但是它的大多数语句都是表达式和分号构成的；同时，函数的返回值出现在最后一个语句时不需要使用 `return` 关键字。
- 默认为 `const`：**Rust** 中的所有变量都默认不可变。
- 所有权：一份资源有且仅有一个变量对其有所有权，它会在变量所在作用域结束时被释放。这和 **C++** 中的 `std::unique_ptr` 非常相似。
- 所有权传递：多数情况下，变量的赋值（或函数参数传递）会将所有权转移到另一个变量或函数当中，此时原先的变量就不再有效。
- 可变引用：任何时刻对一个变量可以存在多个不可变引用；但只能存在一个可变引用，此时不能存在任何其它（可变或不可变）引用。

具体的内容，就让我们在正文中详细了解吧。



[TOC]



## 基础

### 变量的声明

我们用 `let` 关键字来声明变量，变量的类型可以通过初始化的值来推导：

```rust
fn main() {
    let x = 42;
    println!("x is {}", x);
    x = 24;						// 错误！不能对不可变变量赋值
}
```

和上面效果相同的 **C++** 代码如下：

```cpp
int main() {
    auto const x = 42;
    std::cout << std::format("x is {}", x);
    x = 24;
    return 0;
}
```

可以看到，**Rust** 的一大特征是“省字”：函数的声明根本没有类型；所有变量默认为不可变，而且 `let` 也比 `auto` 要短；`println!` 是一个 **宏（Macro）**，后者在 **Rust** 中的功能非常强大（而且是类型安全的，对比 **C/C++** 中简单粗暴的文本替换）。

如果要改变变量的值，可以将其声明为 `mut` 的：

```rust
fn main() {
    let mut x = 42;
    println!("x is {}", x);
    x = 24;
    println!("now x is {}", x);
}
```

值得一提的是，不可变变量并不是常量（我猜想可能通过 `unsafe` 来修改？），**Rust** 中的常量是通过 `const` 声明的变量：

```rust
fn main() {
    const SEVEN_HOUR_IN_SECONDS : u32 = 7 * 60 * 60;
}
```

和 `let` 不同的是，`const` 要求显式写出变量类型（这很奇怪），这里的 `u32` 是一个 32 位无符号整数类型。**Rust** 中的 `const` 有点类似于 **C++** 的 `constexpr` 或 `static constexpr`，它可以进行常量折叠，并拥有静态存储类型（在程序的整个过程中都存在）。某种程度上，`const` 是 **Rust** 中最令人安心的关键字。

**Rust** 中还有一个比较令人惊讶的变量操作，那就是 **Shadowing**；我们可以利用 `let` 关键字重新定义一个变量：

```rust
fn main() {
    let x = 42;
    let x = "abc";			// 原来的变量被丢弃了
    {
        let x = x.chars();	// 和 C++ 等语言中类似的变量隐藏
    }
    println!("{}", x);		// 输出 abc
}
```

某种角度来讲这并非新鲜事，因为很多语言中本来就可以通过大括号在函数中建立作用域；在这些作用域中我们可以定义同名变量来隐藏外部变量。**Rust** 只是允许在同一作用域中隐藏变量而已；只不过由于在同一个作用域中，变量原本的定义没法通过新变量作用域的结束而暴露出来了。

### 基本类型

**Rust** 将类型分为 **标量类型（Scalar Type）** 和 **复合类型（Compound Type）**。前者包含了我们熟知的整数与浮点数等基本类型；后者则包含 **元组（Tuple）** 和 **数组（Array）** 类型。

**Rust** 的类型命名颇为简洁清晰，`i` 开头的就是无符号整数类型；`u` 开头的则是有符号整数类型；`f` 开头的是浮点数类型。这些前缀后面接着一个数字，就代表了改类型的长度（以位为单位）。比如 `u16` 是 16 位无符号整数，`f32` 是 32 位（单精度）浮点数。此外，`isize` 和 `usize` 分别代表了当前系统位数的有符号和无符号整数类型。

此外，`bool` 和 `char` 代表了我们熟悉的两种基本类型。

**Rust** 支持原生的元组类型，其用法和 **Python** 及其相似：

```rust
fn main() {
    let tup = (42, "abc", 1.0);		// 类型为 (i32, &str, f64)
    let (a, b, c) = tup;
    println!("{}", tup.1);
}
```

不过访问元组元素的方式是利用成员访问加上一个数字，略显另类。**C++** 中也可以写出和上面类似的代码：

```cpp
int main() {
    auto tup = std::tuple(42, "abc", 1.0);
    auto [a, b, c] = tup;					// （C++17）结构化绑定
    std::cout << std::get<1>(tup) << '\n';
    return 0;
}
```

从这个角度来看，怎么都是 **Rust** 要简洁清晰一些。值得一提的是，空元组类型 `()` 在 **Rust** 中被运用为 **单元类型（Unit Type）**，所有没有值的表达式（和函数）都返回单元值 `()`，这一点是要比 **C/C++** 等语言中的 `void` 更为精妙的。

**Rust** 的数组也和 **Python** 风格相似：

```rust
fn main() {
    let arr = [1, 2, 3];		// 类型为 [i32; 3]
    let [a, b, c] = arr;
    println!("{}", arr[1]);
    let arr = [1;5];			// 定义为 [1, 1, 1, 1, 1]
}
```

在 **Rust** 中，数组的长度会记入其类型，因此和 **C/C++** 类似，我们不能向数组添加元素，也不能在不同大小的数组间赋值。和 **C/C++** 不同的是，**Rust** 会在运行时检查数组上下界。

### 函数

**Rust** 中的函数有特别的地位。首先，其不需要先声明再使用：

```rust
fn main() {
    foo();
}
fn foo() {
    // 省略定义
}
```

事实上，`foo` 甚至不一定需要定义在当前文件中。这实际上为编译造成了很大的困难，比如推断表达式的类型，我不清楚 **Rust** 编译器是怎么克服这一点的。和 **C++** 不同，**Rust** 要求函数返回类型不为 `()` 时必须写出函数返回值（这倒是大大简化了编译）：

```rust
fn foo() {				// 默认返回 ()
    // 省略定义
}
fn bar() -> i32 {		// 哪怕返回值一眼就能看出来，也必须写出其类型
    return 42;
}
```

相比之下，**C++** 可以解放双手：

```cpp
auto foo() {
    // 该返回什么类型就返回什么类型
}
```

**Rust** 的函数参数采用和声明时类似的语法，用 `var : type` 的形式：

```rust
fn foo(x : i32, y : f64) {
    // 省略定义
}
```

函数体是由许多语句组成的；**Rust** 中的语句大多是表达式加上分号。一个作用域（一对大括号）作为表达式的值是中的最后一个表达式的值，因此可以写出下面这样的效果：

```rust
fn main() {
    let x = {
        let y = 42;
        y + 1
    };				// 这里大括号作用域是一个表达式，将里面最后的一个表达式的值传出去
}
```

类似地，函数体本身也是一个大括号围成的表达式，因此函数最后的表达式可以直接作为返回值：

```rust
fn foo(x : i32) -> i32 {
    if x > 42 {
        x - 42				// 注意这里不能加上分号，否则返回的就是 ()
    } else {
        -x + 42
    }
}
```

个人不是很喜欢这种风格，因为大括号（相比小括号）给我一种隔离感，因此其作为值不应该写得这么直接（也就是应该加上 `return` 关键字）。因此后文中我会避免用这种写法。

### 控制流

控制流我们已经熟悉得不能再熟悉了，就是 `if`、`while`、`for` 那一套东西，它自从 **C** 发迹之后基本上在各个语言里万变不离其中。下面只提一些 **Rust** 中不太一样的：

- 表达式不需要小括号了，比如 **C++** 中的 `if (cond)` 在 **Rust** 中可以写成 `if cond`。

- 无条件循环官方推荐使用 `loop` 而非 `while true`（这个语法糖意义不明）。

- `for` 等同于 **C++** 中的 `range for`，也即作为集合的遍历工具。语法上和 **Python** 一致，使用 `for elem in coll` 的格式。

- **Rust** 支持为循环贴标签，并以此指定 `break` 或 `continue` 某个循环（这一点简直太好用了）：

  ```rust
  fn main() {
      let arr = [1, 2, 3];
      'outer: for i in &arr {
          for j in 1..5 {				// 相当于 Python 的 range(1, 5)
              if i + j > 5 {
                  continue 'outer;
              }
              println!("{}, {}", i, j);
          }
      }
  }
  ```

- 循环可以通过 `break` 得到一个值（这个算是一个奇怪的语法糖）：

  ```rust
  fn main() {
      let x = for i in 1..10 {
          if i % 7 == 0 {
              break i + 42
          }
      }
  }
  ```

  这里 `break` 的作用和 `return` 类似，只不过它只跳出最内部的循环。

## 所有权

### 回顾：**C/C++**

**所有权（Ownership）** 是 **Rust** 独特的资源管理机制，其灵感可能来自于 **C++** 的 **RAII（Resource Acquisition Is Initialization）**，可惜的是后者对 **RAII** 没有任何强制手段，程序员依然可以照搬 **C** 那种狂野式的资源管理模式。

让我们先回顾一下 **C**、**C++** 这两种语言中内存管理的方式~~（**GC** 语言不提也罢，都属于让别人擦屁股的）~~。**C**（沿袭到 **C++**） 采用三种典型的存储周期模型：

- 自动存储周期：存储在栈上，在作用域结束自动释放资源。不会出现内存泄露，但可能产生悬浮指针。
- 静态存储周期：存储在程序独有的数据区，在程序整个过程中都有效。不会出现内存泄露或悬浮指针。
- 动态存储周期：存储在堆上，手动进行管理。内存安全的重灾区。

说到底，指针这种设计本来就是信息不足的；下面让我们细数它可能产生的安全问题：

```c
int *dangling() {
    int i;
    return &i;			// 悬浮指针，i 在函数结束后被销毁，因此指向它的指针是无效的
}
int *new() {
    return malloc(sizeof(int));	// 返回了指向动态存储周期对象的指针，因此需要调用方手动销毁，否则会内存泄露
}
int *null() {
    return NULL;		// 返回了空指针；如果调用方没有检查，会产生空指针错误
}
int *safe() {
    static int x = 42;
    return &x;			// 返回了指向静态存储周期对象的指针，不考虑并行的情况很安全了，但如果调用方尝试释放这段内存呢？
    					// 如果考虑并行：这样同一段内存如何处理 race condition？
}
void foo() {
    int *ptr = malloc(sizeof(int));
    int *cpy = ptr;
    free(cpy);			// 释放了 cpy 指向的内存，现在 cpy 和 ptr 都是悬浮指针
    free(ptr);			// 错误，二次释放！可我怎么知道这些指针的浅拷贝中我应该删除哪个呢？
}

int *resrc();			// 灵魂发问：请问返回的指针指向的是什么地方？需不需要用户进行管理？可不可能是空指针？
void call(int *ptr, char **arrptr);
						// 再次灵魂发问：这里的两个指针是否需要提前分配动态内存，还是说自动/静态存储周期就好？
						// 在调用后这些指针已经被释放了么？还是说可能被重指向新的动态内存？
						// 可以传入 NULL 么？
```

因此写 **C** 的时候，我们必须反复查阅库文档，了解每个资源相关函数的行为（同时还要考虑线程安全）。

**C++** 引入了 **RAII** 来应对头疼的指针问题：所有资源都被一个对象管理；资源分配出现在对象的初始化，而对象析构时资源就会被释放。支持这个机制的语言特性是构造函数和析构函数：

```cpp
struct Foo {
    Foo(int ct)
        : arr(new int[ct]) {}	// 构造函数中分配资源
    ~Foo() {
        delete[] arr;			// 析构函数中释放资源
    }
    int* arr;
};
Foo make_array(int ct) {
    return Foo(ct);				// 返回的对象构造时出现了资源分配，但其生命周期和所在对象的生命周期是一致的。
}
int main() {
    auto foo = make_array(42);	// foo 现在作为 Foo 类型管理了这个动态资源。
    							// foo 本身是自动存储周期，因此在函数结束时会自动释放；彼时其管理的资源也会被释放
    return 0;
}
```

**C++11** 也引入了利用 **RAII** 的 `std::unique_ptr` 来作为裸指针的替代（以及 `std::shared_ptr` 用于需要多个资源管理者的情形）；**RAII** 的运用理论上可以解决很大比例的内存管理问题，但是架不住 **C++** 的窟窿太多了，其中一个就是引用：

```cpp
int& foo() {
    int x;
    return x;					// 直接返回无效引用，这和悬垂指针如出一辙
}
auto get_closure() {
    int x;
    return [&](auto y) { return x + y; };	// 闭包对象没问题，有问题的是捕获列表中的 &x，它在离开函数作用域后就失效了
}
struct Foo {
	int x;
    auto foo() {
        return [&] { return x; };			// 自动捕获 &(*this)，因此 Foo 对象销毁后，这个闭包就有内存问题了。
    }
};
```

我们当然也想解决引用的时效问题，但是它们没办法通过智能指针管理，因为这些资源并不一定是动态的；另一方面，我们也不能因此将所有变量都声明为 `std::shared_ptr`，这是对性能的极大浪费。这是 **C++** 的顽疾。

### **Rust** 中的所有权

现在让我们看看 **Rust** 的解决方案。正如我们在最开始就提到的，**Rust** 中的任何资源都有唯一的所有者（某个变量），这类似于 **C++** 的 **RAII**。**Rust** 的 **特性（Trait）**机制在这里发挥了作用：所有实现了 `Drop` 特性的类型都会在作用域结束时先调用 `drop` 函数。让我们以 `String` 类型为例浏览所有权的特征：

```rust
fn main() {
    let x = String::from("a string");		// 注意到 String 类型区分与直接用双引号构建的字符串
    										// 后者的类型是 &str，等价于 char const*；我们会在后面再说明
    let y = x;					// x 将字符串的所有权转移给了 y，这是 Rust 的默认行为
    println!("{}", x);			// 错误！x 的资源已经被“移动”走了，现在 x 是无效的
}
```

可以看到，**Rust** 进行赋值操作时，默认采用的是类似于 **C++** 中的移动操作，而且将被移动的变量无效化并进行编译时检查（相比之下，**C++** 对于 `std::move` 过的变量没有任何检查）。如果需要深拷贝一个字符串，可以使用它的 `clone` 方法：

```rust
fn main() {
    let x = String::from("a string");
    let y = x.clone();			// x 的内容被复制出来，现在两者都是有效的
    println!("{}, {}", x, y);
}
```

你可能会有点迷惑，明明之前的例子中等号用得好好的，这里怎么突然就说默认行为是所有权转移了？这是因为，**Rust** 的基本类型都实现了 `Copy` 特性，它们在赋值/构造的行为是将数据复制一遍。注意：实现了 `Drop` 特性的类型不能再实现 `Copy` 特性。下面是一些值得记住的实现了 `Copy` 特性的类型：

- 整数和浮点数类型。
- 布尔类型和字符类型。
- 元组类型。

函数的参数也默认通过所有权转移的方式传递；因此许多类型会自动“进入”函数所在作用域中，原先作用域就失效了：

```rust
fn foo(x : String) {
    println!("{}", x);
}
fn main() {
    let x = String::from("a string");
    foo(x);
    println!("{}", x);				// 错误！x 的作用域已经移动到 foo 当中了，因此现在它已经失效。
}
```

当然，实现了 `Copy` 特性的类型会通过复制方式传入。类似地，函数返回值的机理和变量赋值与函数参数传递一样，也根据是否实现 `Copy` 特性来进行复制或移动（所有权转移）。

这种设计当然非常安全，但也带来了一些不便；如果我们希望函数（或者某个嵌套的作用域）临时拥有资源的所有权，并在该作用域结束后将所有权交还给原来的作用域，应该怎么做呢？一个显然的写法是让函数或作用域返回它们：

```rust
fn foo(x : String, y : String) -> (String, String) {
    println!("{}, {}", x, y);
    return (x, y);
}
```

当然，**Rust** 提供了一种方便的语言特性，**引用（Reference）**，来解决这个临时所有权转移问题：

```rust
fn foo(x : &String) {
    println!("{}", x);
}
fn main() {
    let x = String::from("a string");
    foo(&x);
    println!("{}", x);
}
```

这里的 `&` 运算符进行了 **引用借用（Reference Borrowing）**，其颇类似于 **C++** 的取地址运算符 `&`（事实上两者的机理也是一致的）。这样我们就不需要在意原先对象的所有权（因为我们拿到了它的引用）。不过注意引用的类型是 `&T`，因此我们引用的是一个不可变的类型；如果要通过引用修改其借用的资源，需要用 `&mut` 方式借用（且其类型为 `&mut T`）：

```rust
fn foo(x : &mut String) {
    x.push_str(" and more");
}
fn main() {
	let mut x = String::from("a string");
    foo(&mut x);			// &mut 要求其操作的对象必须声明为 mut
    println!("{}", x);
}
```

如开头所提到的，同一个对象的可变引用只能存在一个；当存在可变引用时，不允许存在任何其它引用：

```rust
fn main() {
    let mut x = String::from("a string");
    {
        let r1 = &mut x;			// 没问题
    	let r2 = &mut x;			// 错误！只能存在一个可变引用！ 
        let r3 = &x;				// 错误！如果存在可变引用，不允许再声明变量的引用
    }								// r1, r2, r3 的作用域结束
	let r4 = &x;					// 没问题
    let r5 = &mut x;				// 呃，目前似乎没有问题
    println!("{}, {}", r4, r5);		// 错误！由于在声明可变引用后使用了指向同一对象的不可变引用，出现错误
}
```

可以这样简单理解：可变引用和其它一切引用都互斥；一旦出现了不可变引用，在其入土之前不能出现任何其它引用。这是对并行安全的一种尝试（因为你在某一时刻只能修改一个变量，或者读一个变量）。

**Rust** 对悬垂引用也有编译期的检查：

```rust
fn foo() -> &String {
    let s = String::from("a string");
    return &s;						// 错误！返回一个即将被 drop 的对象的引用
}
```

有关生命周期的内容我们会在后面的章节中介绍，彼时会介绍一种在函数中返回引用的合法方式。

### 切片类型

**Rust** 中的 **切片（Slice）** 返回一个容器的一个子序列（可以和 **C++** 中 `std::string_view` 相对于 `std::string` 的关系进行类比），其由下标运算符和 `..` 记号表示：

```rust
fn main() {
    let s = String::from("a string");
    let a = &s[0..1];
    let string = &s[2..7];
}
```

上面的 `a` 和 `string` 可以理解为指向 `s` 的两个指针，其分别带有一个长度信息。其等价的 **C++** 代码是：

```cpp
int main() {
    std::string s = "a string";
    auto a = std::string_view(s.cbegin() + 0, 1);
    auto string = std::string_view(s.cbegin() + 2, 5);
}
```

如果省略了初始和结束下标的任一个，就会默认为 0 和容器的大小。对于 `String` 来说，其切片的类型是 `&str`。值得注意的是其类型和字符串字面量（如 `"abc"`）是一致的。

由于切片并没有对象的所有权，所以当原对象被销毁时，切片也会被无效化。为了防止其带来的安全问题，**Rust** 用其所有权机制解决了这个问题：

```rust
fn main() {
    let mut s = String::from("a string");
    let a = &s[2..4];
    s.clear();				// Rust 中的成员函数调用会借用其引用，或可变引用。
    						// 这里是一个可变引用，因此和前面的 &s[2..4] 相矛盾了（可变引用与所有其它引用互斥）
    println!("{}", a);		// 错误！在声明可变引用后使用了不可变引用
}
```

和 **C++** 中所建议的类似，我们理应尽量使用字符串的切片类型 `&str` 而非 `String` 本身的引用。

除了字符串的切片（虽然它最常用），我们也可以使用任意数组类型的切片（事实上，`String` 就是一个 `[char]` 的包装）：

```rust
fn main() {
    let arr = [1, 2, 3, 4, 5];
    let slice = &arr[1..3];			// 切片的类型是 &[i32]
    assert_eq!(slice, &[2, 3]);
}
```

## `struct` 结构

### `struct` 的声明和实例化

**Rust** 支持自定义的 `struct`，其颇类似于元组，只不过我们可以定义其中每一项的名称，并对其自定义一些函数（我们可以类比 **C++** 中 `class`/`struct` 定义的类）：

```rust
struct Person {
    name : String,
    age : i32,
    favorite_food : [&str]
}
```

为了生成一个 `Person` 对象，我们需要一项项写出它们的值：

```rust
fn main() {
    let p1 = Person {
        name : String::from("Alice"),
        age : 23,
        favorite_food : ["apple", "banana"]
    };
    let mut p2 = Person {				// 此时所有的成员都自动声明为 mut
        name : String::from("Bob"),
        age : 32,
        favorite_food : ["carrot", "donut"]
    };
    p2.age = 34;
}
```

如果从一个 `Person` 变量构建另一个 `Person` 变量，我们当然可以一个个复制（或移动）出来，但是也可以用一个方便的语法糖：

```rust
fn main() {
    // 我们定义了 p1
    let p2 = Person {
        favorite_food : ["egg", "fried chicken"],
        ..p1					// 这里等同于 name = p1.name, age = p1.age，
        						// 前者移动了 p1 的 name 变量，后者复制了 p1 的 age
    };
}
```

注意 `..` 只能用于 `struct` 对象定义的最后一句。上面的 `p2` 接管了 `p1` 中 `name` 的所有权（而且 `p1` 是不可变的变量），因此 `p1` 没法继续使用了（除非其绑定到新的对象）。

我们也可以定义像元组一样简洁的 `struct`：

```rust
struct RGB(i32, i32, i32);
struct Tag;						// 相当于空元组，等同于 struct Tag();
fn main() {
    let black = Color(0, 0, 0);
    let t = Tag;				// 就好像 let t = (); 其等同于 let t = Tag();
}
```

虽然这种元组 `struct` 和元组高度相似，但是它们的类型和等结构的元组并不相同；事实上，等结构的不同 `struct` 的类型也不同。我们可以将其视作 **C/C++** 中最普通的 `struct`：

```cpp
struct RGB {
    int x, y, z;
};
struct Tag {};
int main() {
    auto black = RGB{ 0, 0, 0 };
    auto t = Tag{};
}
```

上面的例子中，我都很小心地避开了引用类型，这是因为 **Rust** 中如果要在 `struct` 里定义所有权不属于自己的变量，需要用到更加复杂的语法结构，我们会在后面有关生命周期的章节中详细介绍。

### 定义成员函数

成员函数本身也是函数，只不过在 **Rust** 中其定义在一个特殊的代码块 `impl` 中，同时其第一个参数一定是 `self`：

```rust
#[derive(Debug)]			// 这个属性用于为 struct 定义默认的 Debug 特性，这样它就可以通过 println! 打印出来了
struct Rectangle {
    width : u32,
    height : u32
}
impl Rectangle {			// 这里开始是 impl 代码块
    fn area(&self) -> u32 {	// 以引用类型接受 Rectangle 变量，相当于 self : &Rectangle
        return self.width * self.height
    }
}
```

这里的 `self` 关键字颇类似于 **C++** 中的 `this` 关键字，只不过其需要显式声明于成员函数的第一个参数位置。**C++23** 中的 Deducing `this` 语言特性可以让 **C++** 写出基本一样的代码。

和 **C++** 不同的是，**Rust** 无需区分普通类型和引用对成员函数的调用，因此不需要 `->` 这个运算符。

**Rust** 中可以在 `impl` 代码块中定义非成员函数（也就是第一参数不是 `self`）的效果和 **C++** 中的静态成员函数是一样的：

```rust
impl Rectangle {
    fn square(size : u32) -> Rectangle {
        return Rectangle {
            width : size,
            height : size
        };
    }
}
fn main() {
    let s = Rectangle::square(42);
}
```



## 枚举

