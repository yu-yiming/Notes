# x86 学习

[TOC]

本篇笔记中我们将使用 **AT&T(GAS)** 的 **x86** 语法，使用 32 位系统。它和 **Intel** 的标准主要在于，后者的立即数和寄存器不需要前缀；内存地址语法使用 `[]` 结构而非 `()` 结构；操作顺序是从后向前而非从前到后。

## 基础知识

每个 **x86** 语句都由指令和操作数构成，比如 `mov $0x15, %eax` 就是一个语句。其中由空格分开的第一部分是 **指令（Opcode）**，而后面的部分都是 **操作数（Operand）**。可以将操作数分为下面几种：

- **立即数（Immediate）**：也即常数，由 `$` 开始的一个数字序列
- **寄存器（Register）**：代表了处理器中的特殊存储单元，由 `%` 开始的一个字符序列
- **内存地址（Memory Address）**：代表了内存中的某个地址，由 `()` 结构提示，我们会在后文提到

## 寄存器

寄存器的名称并不是随意的字符序列，而是拥有固定名称。x86 的寄存器有下面这些：

| 名称 | 位数 | 名称 | 位数 | 名称 | 位数 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| EAX  | 32   | AX   | 16   | AL   | 8    |
| EBX  | 32   | BX   | 16   | BL   | 8    |
| ECX  | 32   | CX   | 16   | CL   | 8    |
| EDX  | 32   | DX   | 16   | DL   | 8    |
| ESI  | 32   | EDI  | 32   | ESP  | 32   |
| EBP  | 32   |      |      |      |      |

部分寄存器有特殊含义，列出如下：

- EAX：表示返回值
- ECX：循环的计数器
- EDI：重复的终点
- ESI：重复的起点
- EBP：基指针
- ESP：栈指针
- EIP：程序计数器
- EFLAGS：上一个操作的状态

## 声明内存

我们使用 `.data` 指令提示声明静态的内存空间，其后可以用 `.byte` 和 `.short` 等指令声明空间的大小：

```assembly
.data			# 内存空间声明开始
var:			# 冒号结尾的是标签，其可以作为内存位置的引用符（有点类似于变量）
	.byte 42	# 声明了一段值为 42，大小为一个字节的内存
	.byte 10	# 声明了一段值为 10，大小为一个字节的内存，其地址为上一行所在地址 +1
x:
	.short 42	# 声明了一段值为 42，大小为两个字节的内存
y:
	.long 3000  # 声明了一段值为 3000，大小为四个字节的内存
```

可以用逗号相隔的多个数字表示连续开辟的同样大小的内存空间（类似于数组），或使用 `.zero` 指令开辟初始化为 0 的给定大小内存空间。`.string` 则可以分配一个以 `\0` 结尾的 **ASCII** 字符串（类似于 **C** 中的字符串）：

```assembly
.data
arr:
	.byte 1, 2, 3	# 声明了一段值为 1, 2, 3 的连续单字节内存
zeros:
	.zero 10		# 声明了一段值全为 0 的 10 字节内存
str:
	.string "hello"	# 声明了一段值为 'h', 'e', 'l', 'l', 'o', '\0' 的连续单字节内存
```

### 内存操作

**x86** 使用一个特殊的语法来访问内存空间，比如将 `Mem[EBP + 8 + 4 * ECX]` 加载入 `EAX` 可以写作 `mov 8(%ebp, %ecx, 4), %eax`，注意到这里出现的数字不需要 `$`，因为它们并不是立即数。其语法解释如下：

`displacement(base_reg, offset_reg, multiplier)` => `base_reg + displacement + offset_reg * multiplier`

其中并不是所有项都是必须的。作为举例，下面是一段 **C** 代码：

```c
typedef struct {
    int a, b, c, d;
} foo_t;
foo_t my_foos[10];
my_foos[5].c = 461;
```

我们可以尝试写出与其等价的 **x86** 指令（我们这里假设 `EBX` 存储了指向 `my_foos` 的指针：

```assembly
mov $5, %ecx
movl $461, 8(%ebx, %ecx, 16)	# 这里的 8 是因为 c 处于第三个；16 是因为取的是 my_foos[5]（默认 sizeof(int) 是 4）
```

上面出现的 `movl` 是对 `mov` 使用了运算后缀 `l` 的指令。通常不带后缀的指令会根据寄存器的类型来决定其操作的位数；但如果将立即数作为操作数时，其操作位数就变得不可预知了。这时候可以用后缀 `b`、`w` 或 `l` 来指定操作的位数（1、2 或 4）。

## 指令详解

下面我们约定对操作数的格式作出特定的记号：

- `<reg32>`、`<reg16>`、`<reg8>` 分别代表 32 位、16 位和 8 位的寄存器；`<reg>` 表示任意寄存器
- `<mem>` 代表内存地址
- `<imm32>`、`<imm16>`、`<imm8>` 分别代表 32 位、16 位和 8 位的立即数
- `<label>` 代表标签，也即程序指令地址

### 移动指令

- `mov` 指令：将第一个操作数的值复制给第二个操作数。不过需要注意，这里不支持从内存地址复制到内存地址 ：
  - 语法：
    - `mov <reg>, <reg>`
    - `mov <reg>, <mem>`
    - `mov <mem>, <reg>`
    - `mov <imm>, <reg>`
    - `mov <imm>, <mem>`
  - `mov` 指令可以使用操作后缀
  - 举例：`mov $5, var(, 1)`
- `push` 指令：将操作数的值（32 位长度的内存）推入栈顶，其等价于将 ESP 减少 4 后将操作数的值存入 (ESP)：
  - 语法：
    - `push <reg32>`
    - `push <mem>`
    - `push <imm32>`
  - 举例： `push %eax`
- `pop` 指令：将栈顶的值推出并存入操作数中，其等价于将栈顶的值存入操作数后将 ESP 增加 4：
  - 语法：
    - `pop <reg32>`
    - `pop <mem>`
  - 举例： `pop var(, 1)`
- `lea` 指令：将第一个操作数的内存地址存入第二个操作数中（类似于取地址操作）：
  - 语法：
    - `lea <mem>, <reg32>`
  - 举例： `lea (%ebx, %esi, 8), %edi`

### 算术和逻辑指令

- `add`、`sub` 指令：整数加减法，将第一个操作数对第二个操作数进行运算的值存入第二个操作数。注意依然不允许两个操作数均为内存地址：
  - 语法（下面的 `add` 也可以替换为 `sub`）：
    - `add <reg>, <reg>`
    - `add <reg>, <mem>`
    - `add <mem>, <reg>`
    - `add <imm>, <reg>`
    - `add <imm>, <mem>`
  - `add` 和 `sub` 指令可以使用操作后缀
  - 举例：`add %ah %al`
- `inc`、`dec` 指令：整数自增和自减运算，将操作数自身进行运算：
  - 语法（下面的 `inc` 也可以替换为 `dec`）：
    - `inc <reg>`
    - `inc <mem>`
  - `inc` 和 `dec` 指令可以使用操作后缀
  - 举例：`inc %ax`
- `imul` 指令：整数乘法，将第一个操作数和第二个操作数的乘积存入第二个操作数，或存入第三个操作数。这个指令对操作数的要求比较复杂，详细请看下面：
  - 语法：
    - `imul <reg32>, <reg32>`
    - `imul <mem>, <reg32>`
    - `imul <imm>, <reg32>, <reg32>`
    - `imul <imm>, <mem>, <reg32>`
  - 举例：`imul (%ebx), %eax`
- `idiv` 指令：整数乘法，将 `EDX` 作为被除数的最高 32 位，EAX 作为被除数的最低 32 位，操作数作为除数，在运算后将商存入 EAX，将余数存入 EDX：
  - 语法：
    - `idiv <reg32>`
    - `idiv <mem>`
  - `idiv` 指令可以使用操作后缀
  - 举例：`idiv %ebx`
- `and`、`or`、`xor` 指令：整数与或异或运算，规则和加减运算一致
  - 语法（下面的 `and` 也可以替换为 `or` 或 `xor`）：
    - `and <reg>, <reg>`
    - `and <reg>, <mem>`
    - `and <mem>, <reg>`
    - `and <imm>, <reg>`
    - `and <imm>, <mem>`
  - `and`、`or`、`xor` 指令可以使用操作后缀
  - 举例：`and $0x0f, %eax`
- `not`、`neg` 指令：整数非运算和取负运算，将操作数进行运算后存入操作数：
  - 语法（下面的 `not` 也可以替换为 `neg`）：
    - `not <reg>`
    - `not <mem>`
  - `not`、`neg` 指令可以使用操作后缀
  - 举例：`not $eax`
- `shl`、`shr` 指令：将第一个操作数向左或右移动第二个操作数给定的位数。第二个操作数会对 32 进行求余，其可以是一个立即数或 CL 寄存器：
  - 语法（下面的 `shl` 也可以替换为 `shr`）：
    - `shl <imm8>, <reg> `
    - `shl <imm8>, <mem>`
    - `shl %cl, <reg>`
    - `shl %cl, <mem>`
  - `shl`、`shr` 指令可以使用操作后缀
  - 举例：`shl %eax, 1`

### 控制流指令

**x86** 中的 EIP 寄存器是程序计数器，其表示程序当前执行的指令地址。我们不能直接修改这个寄存器，但可以通过控制流指令对其隐式更新。为了得到某一行代码的指令地址，可以使用标签。

- `jmp` 指令：无条件跳转到一个地址：
  - 语法：
    - `jmp <label>`
  - 举例：`jmp end`
- `je`、`jne`、`jz`、`jg`、`jge`、`jl`、`jle` 指令：当状态位 EFLAGS 满足一些条件时，跳转到一个地址：
  - 语法（下面的 `je`（相等） 可以替换为 `jne`（不相等）、`jz`（等于 0）、`jg`（大于）、`jge`（大于等于）、`jl`（小于）、`jle`（小于等于））：
    - `je <label>`
  - 举例：`jz end`
- `cmp` 指令：规则与 `sub` 基本一致，只不过其结果会被舍弃：
  - 语法：
    - `cmp <reg>, <reg>`
    - `cmp <mem>, <reg>`
    - `cmp <reg>, <mem>`
    - `cmp <imm>, <reg>`
  - `cmp` 指令可以使用操作后缀
  - 举例：`cmpb $10, (%ebx)`
- `call`、`leave`、`ret` 指令：函数调用和返回指令。`call` 会将当前指令地址推入栈中（使用 `push` 指令），然后无条件跳转到函数地址，即某个标签处（使用 `jmp` 指令）。`leave` 将栈顶的内容（一个指令地址）推出（使用 `pop` 指令）并赋给 EBP，然后 `ret` 无条件跳转到该地址（使用 `jmp` 指令）：
  - 语法：
    - `call <label>`
    - `ret`
  - 举例：`call foo`

## 函数调用约定

从上面函数调用和返回指令中我们看到，函数调用的本质就是一个无条件的地址跳转，系统没有做任何多余的事情。因此我们需要一个 **调用约定（Calling Convention）** 来规范函数调用，使得不同开发者能够不容易出错地调用各自编写的函数。下面我们将介绍 **C** 语言的调用约定。

### 调用者规定

在函数调用处需要遵守的规定被称为 **调用者规定（Caller Rules）**：

- 调用前需要确认 EAX、ECX 和 EDX 寄存器的值推入栈中，因为它们可能会在函数中被修改
- 函数参数通过推入栈中进行传递
- 使用 `call` 调用函数，其自动将返回地址推入栈顶并跳转到函数地址
- 调用后将参数从栈顶推出。这只需要将 ESP 增加相应大小的值即可做到
- 将 EAX、ECX 和 EDX 的值从栈中推出，需要注意顺序要和推入的顺序正好相反

举例如下：

```assembly
push (%ebx)		# 最后一个参数
push $42		# 倒数第二个参数
push %eax		# 第一个参数
call foo		# 调用函数
add $12, %esp	# 清空之前用的参数
```

### 被调用者规定

函数开始和结束时需要遵守的规定被称为 **被调用者（Callee Rules）**：

- 将 EBP 推入栈，然后将 ESP 的值存入 EBP。这是因为 EBP 通常用于寻找局部变量，而在函数调用后，需要更新这个基准地址（因为调用前，函数参数和返回地址已经被推入栈中了）
- 将所有局部变量分配在栈上。这只需要通过将 ESP 减少相应大小的值即可做到
- 确认 EBX、EDI 和 ESI 寄存器的值已经被存在别的地方，因为它们可能会在这个函数中被修改
- 将 EAX 作为函数返回值的寄存器
- 将 EBX、EDI 和 ESI 的值从栈中推出，需要注意顺序要和推入的顺序正好相反
- 将函数的局部变量从栈中推出，这可以通过将 EBP 的值存入 ESP 做到
- 在函数结束之前，从栈中推出 EBP 的值，使其恢复调用前的值
- 使用 `ret` 让函数返回，其自动从栈顶找到返回地址、弹出并跳转到对应位置

举例如下：

```assembly
.text			# 代码部分开始
.globl foo		# foo 是一个全局函数，可以被外部使用
.type foo, @function

foo:
# 函数的调用时准备
	push %ebp			# 存储调用处的 EBP
	mov %esp, %ebp		# 设置新的 EBP
	sub $4, %esp		# 为局部变量预留位置
	push %edi			# 保存 EDI，因为接下来会修改 EDI
	push %esi			# 保存 ESI，因为接下来会修改 ESI
# 函数体
	mov 8(%ebp), %eax	# 将第一个参数存入 EAX
	mov 12(%ebp), %esi	# 将第二个参数存入 ESI
	mov 16(%ebp), %edi	# 将第三个参数存入 EDI
	move %edi, -4(%ebp)	# 将 EDI 存入局部变量中
	add %esi, -4(%ebp)	# 对局部变量加上 ESI 的值
	add -4(%ebp), %eax	# 将局部变量的值加上 EAX 存入返回值
# 函数调用结束时准备
	pop %esi			# 恢复 ESI 的值
	pop %edi			# 恢复 EDI 的值
	mov %ebp, %esp		# 回收局部变量
	pop %ebp			# 恢复 EBP 的值
	ret
```

我们可以还原其 **C** 函数的样子：

```c
int foo(long l, int i1, int i2) {
 	int temp = i2;
    temp += i1;
    return temp + l;
}
```



